import os
import re
import requests
import pythoncom  # <-- ADICIONE ESTA LINHA
from io import BytesIO
from crewai.tools import BaseTool
from pydantic import BaseModel, Field
from docx import Document
from docx.shared import Inches
from docx2pdf import convert

class EscreverDocxInput(BaseModel):
    caminho_ficheiro: str = Field(..., description="The name of the .docx file (e.g., 'report.docx').")
    conteudo: str = Field(..., description="The Markdown text generated by the agent.")

class FerramentaEscreverDocx(BaseTool):
    name: str = "write_docx_tool"
    description: str = (
        "Creates a Word file. The agent must send the text in Markdown"
        "(using # for titles and ![alt](url) for images)."
        "Inputs: caminho_ficheiro (string) - The name of the .docx file to create or overwrite. "
        "conteudo (string) - The Markdown text to write in the Word file, which can include titles (using #, ##, ###) and images (using ![alt](url))."
    )
    args_schema: type[BaseModel] = EscreverDocxInput

    def _run(self, caminho_ficheiro: str, conteudo: str) -> str:
        try:
            
            doc = Document()
            
            linhas = conteudo.split('\n')
            
            for linha in linhas:
                linha_limpa = linha.strip()
                if not linha_limpa:
                    continue
                
                img_search = re.search(r'(!\[.*?\]\((.*?)\))', linha_limpa)
                
                if img_search:
                    markdown_imagem_completo = img_search.group(1) # Pega a tag inteira: ![alt](url)
                    caminho_imagem = img_search.group(2) # Pega só o caminho/url
                    
                    # Remove a tag da imagem da linha para ver se tem texto acompanhando
                    texto_restante = linha_limpa.replace(markdown_imagem_completo, '').strip()
                    
                    # Se tiver texto (ex: "* **Annotated Image Path:**"), escreve no Word primeiro
                    if texto_restante:
                        doc.add_paragraph(texto_restante)
                    
                    # Agora tenta carregar a imagem
                    try:
                        if caminho_imagem.startswith('http'):
                            resposta = requests.get(caminho_imagem)
                            resposta.raise_for_status()
                            imagem_stream = BytesIO(resposta.content)
                            doc.add_picture(imagem_stream, width=Inches(5.0), height=Inches(3.0))
                        else:
                            if os.path.exists(caminho_imagem):
                                doc.add_picture(caminho_imagem, width=Inches(5.0), height=Inches(3.0))
                            else:
                                doc.add_paragraph(f"[Aviso: Imagem local não encontrada em: {caminho_imagem}]")
                    except Exception as e:
                        doc.add_paragraph(f"[Erro ao carregar a imagem: {caminho_imagem}]")
                    
                    continue # Pula para a próxima linha
                    
                # 2. VERIFICA TÍTULOS
                if linha_limpa.startswith('# '):
                    doc.add_heading(linha_limpa.replace('# ', ''), level=1)
                elif linha_limpa.startswith('## '):
                    doc.add_heading(linha_limpa.replace('## ', ''), level=2)
                elif linha_limpa.startswith('### '):
                    doc.add_heading(linha_limpa.replace('### ', ''), level=3)
                    
                # 3. TEXTO NORMAL
                else:
                    doc.add_paragraph(linha_limpa)
            
            doc.save(caminho_ficheiro)
            pdf_path = caminho_ficheiro.replace(".docx", ".pdf")
            
            # --- INÍCIO DA CORREÇÃO PARA O WINDOWS COM ---
            pythoncom.CoInitialize() # Inicializa o COM para esta thread
            try:
                convert(caminho_ficheiro, pdf_path)
            finally:
                pythoncom.CoUninitialize() # Libera os recursos (boa prática)
            # --- FIM DA CORREÇÃO ---

            print(f"Arquivo '{pdf_path}' salvo com sucesso.")
            return {
                "success": True,
                "pdf_path": pdf_path
            }
        
        except Exception as e:
            # Retornar o erro como dicionário também ajuda a padronizar!
            return {"success": False, "error": f"Erro ao tentar salvar/converter o DOCX: {str(e)}"}
